import os
import re
import time
import json
import shutil
import asyncio
import base64
from datetime import date, datetime
from aiohttp import web, ClientSession, ClientTimeout

from pyrogram import Client, filters, types, enums, idle, errors
from yt_dlp import YoutubeDL

# =======================
# LOAD ALL FROM ENVIRONMENT
# =======================
API_ID = os.getenv("API_ID")
API_HASH = os.getenv("API_HASH")
BOT_TOKEN = os.getenv("BOT_TOKEN")
CHANNEL_ID = os.getenv("CHANNEL_ID")
OWNER_ID = os.getenv("OWNER_ID")
YOUTUBE_API_KEY = os.getenv("YOUTUBE_API_KEY")
COOKIES = os.getenv("COOKIES")
COOKIES_BASE64 = os.getenv("COOKIES_BASE64")  # Alternative: base64 encoded cookies
INVITE_LINK = os.getenv("INVITE_LINK", "https://t.me/+eooytvOAwjc0NTI1")

# Decode base64 cookies if provided
if COOKIES_BASE64 and not COOKIES:
    try:
        COOKIES = base64.b64decode(COOKIES_BASE64).decode('utf-8')
        print("ğŸª Decoded cookies from base64")
    except:
        print("âš ï¸ Failed to decode COOKIES_BASE64")

# =======================
# VALIDATE ENVIRONMENT
# =======================
print("=" * 60)
print("ğŸ” ENVIRONMENT VARIABLES CHECK")
print("=" * 60)
print(f"API_ID: {'SET âœ…' if API_ID else 'NOT SET âŒ'}")
print(f"API_HASH: {'SET âœ…' if API_HASH else 'NOT SET âŒ'}")
print(f"BOT_TOKEN: {'SET âœ…' if BOT_TOKEN else 'NOT SET âŒ'}")
print(f"CHANNEL_ID: {'SET âœ…' if CHANNEL_ID else 'NOT SET âŒ'}")
print(f"OWNER_ID: {'SET âœ…' if OWNER_ID else 'NOT SET âŒ'}")
print(f"YOUTUBE_API_KEY: {'SET âœ…' if YOUTUBE_API_KEY else 'NOT SET âš ï¸'}")
print(f"COOKIES: {'SET âœ…' if COOKIES else 'NOT SET âš ï¸'}")
print("=" * 60)

missing = []
if not API_ID:
    missing.append("API_ID")
if not API_HASH:
    missing.append("API_HASH")
if not BOT_TOKEN:
    missing.append("BOT_TOKEN")
if not CHANNEL_ID:
    missing.append("CHANNEL_ID")
if not OWNER_ID:
    missing.append("OWNER_ID")

if missing:
    print(f"\nâŒ ERROR: Missing required variables: {', '.join(missing)}")
    exit(1)

try:
    API_ID = int(API_ID)
    CHANNEL_ID = int(CHANNEL_ID)
    OWNER_ID = int(OWNER_ID)
    print(f"âœ… Variables validated! Owner: {OWNER_ID}")
except ValueError:
    print("âŒ ERROR: API_ID, CHANNEL_ID, OWNER_ID must be numbers!")
    exit(1)

# =======================
# CONFIG
# =======================
DOWNLOAD_DIR = "/tmp/downloads"
THUMB_DIR = "/tmp/thumbnails"
DB_FILE = "/tmp/bot_db.json"
DAILY_LIMIT = 5 * 1024 * 1024 * 1024  # 5GB

# =======================
# COOKIES MANAGEMENT (FIXED)
# =======================
COOKIES_PATH = None
COOKIES_EXPIRED = False
COOKIES_EXPIRY_DATE = None
COOKIE_WARNING_SENT = False

def fix_cookie_format(cookies_content: str) -> str:
    """Fix cookie format issues from environment variable"""
    if not cookies_content:
        return None
    
    # Replace literal \n with actual newlines
    content = cookies_content.replace('\\n', '\n')
    
    # Replace literal \t with actual tabs
    content = content.replace('\\t', '\t')
    
    # Fix common issues
    lines = []
    for line in content.strip().split('\n'):
        line = line.strip()
        if not line:
            continue
        if line.startswith('#'):
            lines.append(line)
            continue
        
        # Replace multiple spaces with tab
        parts = line.split()
        if len(parts) >= 7:
            lines.append('\t'.join(parts))
        elif '\t' in line:
            lines.append(line)
    
    # Ensure Netscape header exists
    result = '\n'.join(lines)
    if '# Netscape' not in result and '# HTTP Cookie' not in result:
        result = '# Netscape HTTP Cookie File\n# Generated by bot\n\n' + result
    
    return result

def parse_cookie_expiry(cookies_content: str) -> datetime:
    """Parse cookies and find earliest expiry date"""
    if not cookies_content:
        return None
    
    earliest_expiry = None
    
    try:
        for line in cookies_content.strip().split('\n'):
            if line.startswith('#') or not line.strip():
                continue
            
            parts = line.split('\t')
            if len(parts) >= 5:
                try:
                    expiry_timestamp = int(parts[4])
                    if expiry_timestamp > 0:
                        expiry_date = datetime.fromtimestamp(expiry_timestamp)
                        if earliest_expiry is None or expiry_date < earliest_expiry:
                            earliest_expiry = expiry_date
                except:
                    continue
    except:
        pass
    
    return earliest_expiry

def check_cookies_expiry() -> tuple:
    """Check if cookies are expired"""
    global COOKIES_EXPIRED, COOKIES_EXPIRY_DATE
    
    if not COOKIES_PATH or not os.path.exists(COOKIES_PATH):
        return False, None, "No cookies file"
    
    try:
        with open(COOKIES_PATH, 'r') as f:
            content = f.read()
    except:
        return False, None, "Cannot read cookies"
    
    expiry = parse_cookie_expiry(content)
    COOKIES_EXPIRY_DATE = expiry
    
    if expiry is None:
        COOKIES_EXPIRED = False
        return False, None, "Cookies loaded (expiry unknown)"
    
    now = datetime.now()
    
    if expiry <= now:
        COOKIES_EXPIRED = True
        return True, expiry, "EXPIRED!"
    
    days_left = (expiry - now).days
    
    if days_left <= 1:
        return False, expiry, f"âš ï¸ Expiring soon!"
    elif days_left <= 3:
        return False, expiry, f"âš ï¸ Expiring in {days_left} days"
    
    COOKIES_EXPIRED = False
    return False, expiry, f"Valid ({days_left} days left)"

def setup_cookies():
    """Write cookies from env variable to temp file"""
    global COOKIES_PATH, COOKIES_EXPIRED
    
    if not COOKIES:
        print("âš ï¸ No COOKIES variable set - YouTube may have limited functionality")
        return
    
    try:
        fixed_cookies = fix_cookie_format(COOKIES)
        
        if not fixed_cookies:
            print("âš ï¸ Could not parse cookies")
            return
        
        COOKIES_PATH = "/tmp/cookies.txt"
        with open(COOKIES_PATH, "w") as f:
            f.write(fixed_cookies)
        
        # Count valid cookie lines
        lines = [l for l in fixed_cookies.split('\n') if l.strip() and not l.startswith('#')]
        print(f"ğŸª Cookies written: {len(lines)} entries")
        
        # Check expiry
        expired, expiry, message = check_cookies_expiry()
        if expiry:
            print(f"ğŸ“… Expiry: {expiry.strftime('%Y-%m-%d')} - {message}")
        else:
            print(f"ğŸ“ {message}")
        
    except Exception as e:
        print(f"âŒ Cookie error: {e}")
        COOKIES_PATH = None

# =======================
# DATABASE
# =======================
DB = {"users": {}, "sessions": {}}

def db_load():
    global DB
    if os.path.exists(DB_FILE):
        try:
            with open(DB_FILE, "r") as f:
                DB = json.load(f)
        except:
            pass

def db_save():
    try:
        with open(DB_FILE, "w") as f:
            json.dump(DB, f)
    except:
        pass

def user_get(uid: int) -> dict:
    k = str(uid)
    if k not in DB["users"]:
        DB["users"][k] = {
            "thumb": None,
            "state": "none",
            "used": 0,
            "reset": date.today().isoformat(),
            "is_pro": (uid == OWNER_ID),
            "is_banned": False
        }
    if DB["users"][k].get("reset") != date.today().isoformat():
        DB["users"][k]["reset"] = date.today().isoformat()
        DB["users"][k]["used"] = 0
    return DB["users"][k]

def session_get(uid: int):
    return DB["sessions"].get(str(uid))

def session_set(uid: int, data: dict):
    DB["sessions"][str(uid)] = data
    db_save()

def session_clear(uid: int):
    DB["sessions"].pop(str(uid), None)
    user_get(uid)["state"] = "none"
    db_save()

# =======================
# HELPERS
# =======================
def safe_name(n: str) -> str:
    return re.sub(r'[\\/*?:"<>|]', "", n.strip())[:150] or "file"

def get_ext(n: str) -> str:
    return os.path.splitext(n)[1]

def is_yt(url: str) -> bool:
    return any(x in url.lower() for x in ["youtube.com", "youtu.be"])

def is_instagram(url: str) -> bool:
    return "instagram.com" in url.lower()

def extract_video_id(url: str) -> str:
    if "youtu.be/" in url:
        return url.split("youtu.be/")[1].split("?")[0].split("/")[0]
    elif "v=" in url:
        return url.split("v=")[1].split("&")[0]
    elif "/shorts/" in url:
        return url.split("/shorts/")[1].split("?")[0]
    return ""

def human_size(n) -> str:
    if not n:
        return "0B"
    for u in ["B", "KB", "MB", "GB"]:
        if n < 1024:
            return f"{n:.1f}{u}"
        n /= 1024
    return f"{n:.1f}TB"

def human_time(seconds) -> str:
    if not seconds or seconds <= 0:
        return "..."
    seconds = int(seconds)
    if seconds < 60:
        return f"{seconds}s"
    elif seconds < 3600:
        return f"{seconds // 60}m {seconds % 60}s"
    return f"{seconds // 3600}h {(seconds % 3600) // 60}m"

def progress_bar(pct: float) -> str:
    filled = int(pct / 10)
    return "â–ˆ" * filled + "â–‘" * (10 - filled)

def check_daily_limit(uid: int, file_size: int = 0) -> tuple:
    if uid == OWNER_ID:
        return True, float('inf')
    user = user_get(uid)
    if user.get("is_pro"):
        return True, float('inf')
    used = user.get("used", 0)
    remaining = DAILY_LIMIT - used
    if file_size > 0:
        return (used + file_size) <= DAILY_LIMIT, remaining
    return used < DAILY_LIMIT, remaining

async def safe_edit(msg, text, kb=None):
    try:
        return await msg.edit_text(text, reply_markup=kb)
    except:
        return msg

async def is_subscribed(uid: int) -> bool:
    if uid == OWNER_ID:
        return True
    try:
        m = await app.get_chat_member(CHANNEL_ID, uid)
        return m.status in (enums.ChatMemberStatus.MEMBER, enums.ChatMemberStatus.ADMINISTRATOR, enums.ChatMemberStatus.OWNER)
    except:
        return False

async def notify_owner(message: str):
    try:
        await app.send_message(OWNER_ID, message)
    except:
        pass

# =======================
# KEYBOARDS
# =======================
def join_kb():
    return types.InlineKeyboardMarkup([
        [types.InlineKeyboardButton("ğŸ“¢ Join Channel", url=INVITE_LINK)],
        [types.InlineKeyboardButton("âœ… Verify", callback_data="verify_join")]
    ])

def cancel_kb():
    return types.InlineKeyboardMarkup([
        [types.InlineKeyboardButton("âŒ Cancel", callback_data="cancel")]
    ])

def menu_kb(uid):
    kb = [
        [types.InlineKeyboardButton("ğŸ–¼ï¸ Thumbnail", callback_data="menu_thumb"),
         types.InlineKeyboardButton("ğŸ“Š Stats", callback_data="menu_stats")],
        [types.InlineKeyboardButton("â“ Help", callback_data="menu_help")]
    ]
    if uid == OWNER_ID:
        kb.append([types.InlineKeyboardButton("âš™ï¸ Admin", callback_data="admin")])
    kb.append([types.InlineKeyboardButton("âœ–ï¸ Close", callback_data="close")])
    return types.InlineKeyboardMarkup(kb)

def thumb_kb():
    return types.InlineKeyboardMarkup([
        [types.InlineKeyboardButton("ğŸ‘ï¸ View", callback_data="thumb_view"),
         types.InlineKeyboardButton("ğŸ—‘ï¸ Delete", callback_data="thumb_del")],
        [types.InlineKeyboardButton("ğŸ”™ Back", callback_data="back")]
    ])

def upload_kb():
    return types.InlineKeyboardMarkup([
        [types.InlineKeyboardButton("âœï¸ Rename", callback_data="rename"),
         types.InlineKeyboardButton("ğŸ“„ File", callback_data="up_file"),
         types.InlineKeyboardButton("ğŸ¬ Video", callback_data="up_video")],
        [types.InlineKeyboardButton("âŒ Cancel", callback_data="cancel")]
    ])

def rename_kb():
    return types.InlineKeyboardMarkup([
        [types.InlineKeyboardButton("ğŸ“ Default", callback_data="ren_def"),
         types.InlineKeyboardButton("âœï¸ Custom", callback_data="ren_cust")],
        [types.InlineKeyboardButton("ğŸ”™ Back", callback_data="back_up")]
    ])

def yt_kb():
    return types.InlineKeyboardMarkup([
        [types.InlineKeyboardButton("ğŸ¬ 1080p", callback_data="yt_1080"),
         types.InlineKeyboardButton("ğŸ¬ 720p", callback_data="yt_720"),
         types.InlineKeyboardButton("ğŸ“¹ 480p", callback_data="yt_480")],
        [types.InlineKeyboardButton("ğŸ“¹ 360p", callback_data="yt_360"),
         types.InlineKeyboardButton("ğŸµ MP3 320k", callback_data="yt_mp3_320"),
         types.InlineKeyboardButton("ğŸµ MP3 192k", callback_data="yt_mp3")],
        [types.InlineKeyboardButton("âŒ Cancel", callback_data="cancel")]
    ])

def admin_kb():
    return types.InlineKeyboardMarkup([
        [types.InlineKeyboardButton("ğŸ“Š Stats", callback_data="adm_stats"),
         types.InlineKeyboardButton("ğŸ“¢ Broadcast", callback_data="adm_bc")],
        [types.InlineKeyboardButton("ğŸ‘‘ Pro", callback_data="adm_pro"),
         types.InlineKeyboardButton("ğŸš« Ban", callback_data="adm_ban")],
        [types.InlineKeyboardButton("âœ… Unban", callback_data="adm_unban"),
         types.InlineKeyboardButton("ğŸª Cookies", callback_data="adm_cookies")],
        [types.InlineKeyboardButton("ğŸ”™ Back", callback_data="back")]
    ])

def bc_kb():
    return types.InlineKeyboardMarkup([
        [types.InlineKeyboardButton("âœ… Send", callback_data="bc_yes"),
         types.InlineKeyboardButton("âŒ Cancel", callback_data="bc_cancel")]
    ])

# =======================
# YOUTUBE API
# =======================
async def get_youtube_video_info(video_id: str) -> dict:
    if not YOUTUBE_API_KEY:
        return None
    try:
        url = f"https://www.googleapis.com/youtube/v3/videos?part=snippet,contentDetails&id={video_id}&key={YOUTUBE_API_KEY}"
        timeout = ClientTimeout(total=10)
        async with ClientSession(timeout=timeout) as session:
            async with session.get(url) as resp:
                if resp.status != 200:
                    return None
                data = await resp.json()
                if not data.get("items"):
                    return None
                item = data["items"][0]
                snippet = item.get("snippet", {})
                return {
                    "title": snippet.get("title", "Unknown"),
                    "channel": snippet.get("channelTitle", "Unknown"),
                }
    except:
        return None

# =======================
# DOWNLOAD FUNCTIONS
# =======================
async def download_from_url(uid: int, url: str, msg, filename: str = None, quality: str = "720"):
    start_time = time.time()
    last_update = 0
    timeout = ClientTimeout(total=600)
    
    try:
        async with ClientSession(timeout=timeout) as session:
            async with session.get(url) as resp:
                if resp.status != 200:
                    raise Exception(f"HTTP {resp.status}")
                
                if not filename:
                    ext = ".mp3" if "mp3" in quality else ".mp4"
                    filename = f"video_{int(time.time())}{ext}"
                
                filename = safe_name(filename)
                path = os.path.join(DOWNLOAD_DIR, filename)
                total = int(resp.headers.get("Content-Length", 0))
                
                allowed, remaining = check_daily_limit(uid, total)
                if not allowed:
                    raise Exception(f"Daily limit exceeded! Remaining: {human_size(remaining)}")
                
                done = 0
                with open(path, "wb") as f:
                    async for chunk in resp.content.iter_chunked(524288):
                        sess = session_get(uid)
                        if sess and sess.get("cancel"):
                            raise Exception("CANCELLED")
                        f.write(chunk)
                        done += len(chunk)
                        
                        now = time.time()
                        if now - last_update >= 2:
                            last_update = now
                            pct = (done / total * 100) if total > 0 else 0
                            speed = done / (now - start_time) if (now - start_time) > 0 else 0
                            await safe_edit(msg,
                                f"â¬‡ï¸ **Downloading...**\n\n"
                                f"`[{progress_bar(pct)}]` {pct:.1f}%\n"
                                f"ğŸ“¦ {human_size(done)} / {human_size(total)}\n"
                                f"âš¡ {human_size(speed)}/s",
                                cancel_kb()
                            )
                
                return path, os.path.splitext(filename)[0]
    except Exception as e:
        raise

async def download_ytdlp(uid: int, url: str, msg, quality: str = "720"):
    await safe_edit(msg, "ğŸ”„ **Downloading with yt-dlp...**", cancel_kb())
    
    start_time = time.time()
    last = {"t": 0}
    
    def hook(d):
        sess = session_get(uid)
        if sess and sess.get("cancel"):
            raise Exception("CANCELLED")
        if d["status"] != "downloading":
            return
        now = time.time()
        if now - last["t"] < 2:
            return
        last["t"] = now
        
        total = d.get("total_bytes") or d.get("total_bytes_estimate") or 0
        done = d.get("downloaded_bytes") or 0
        pct = (done / total * 100) if total > 0 else 0
        
        asyncio.get_event_loop().create_task(safe_edit(msg,
            f"â¬‡ï¸ **Downloading...**\n\n"
            f"`[{progress_bar(pct)}]` {pct:.1f}%\n"
            f"ğŸ“¦ {human_size(done)} / {human_size(total)}",
            cancel_kb()
        ))
    
    opts = {
        "quiet": True,
        "no_warnings": True,
        "outtmpl": f"{DOWNLOAD_DIR}/%(title).70s.%(ext)s",
        "noplaylist": True,
        "progress_hooks": [hook],
        "retries": 5,
        "socket_timeout": 30,
        "nocheckcertificate": True,
        "geo_bypass": True,
        "extractor_args": {
            "youtube": {
                "player_client": ["android", "web"],
            }
        },
        "http_headers": {
            "User-Agent": "com.google.android.youtube/17.36.4 (Linux; U; Android 12) gzip",
        }
    }
    
    # Add cookies if available
    if COOKIES_PATH and os.path.exists(COOKIES_PATH):
        opts["cookiefile"] = COOKIES_PATH
    
    if quality.startswith("mp3"):
        bitrate = "320" if quality == "mp3_320" else "192"
        opts["format"] = "bestaudio/best"
        opts["postprocessors"] = [{
            "key": "FFmpegExtractAudio",
            "preferredcodec": "mp3",
            "preferredquality": bitrate
        }]
    else:
        target = int(quality) if quality.isdigit() else 720
        opts["format"] = f"bestvideo[height<={target}]+bestaudio/best[height<={target}]/best"
        opts["merge_output_format"] = "mp4"
    
    loop = asyncio.get_event_loop()
    
    def do_dl():
        with YoutubeDL(opts) as ydl:
            info = ydl.extract_info(url, download=True)
            path = ydl.prepare_filename(info)
            if quality.startswith("mp3"):
                path = os.path.splitext(path)[0] + ".mp3"
            return path, info.get("title", "video")
    
    return await loop.run_in_executor(None, do_dl)

async def download_invidious(uid: int, url: str, msg, quality: str = "720"):
    video_id = extract_video_id(url)
    if not video_id:
        raise Exception("Invalid YouTube URL")
    
    await safe_edit(msg, "ğŸ”„ **Trying Invidious...**", cancel_kb())
    
    instances = [
        "https://inv.nadeko.net",
        "https://invidious.nerdvpn.de",
        "https://invidious.jing.rocks",
    ]
    
    timeout = ClientTimeout(total=30)
    is_audio = quality.startswith("mp3")
    
    for instance in instances:
        try:
            async with ClientSession(timeout=timeout) as session:
                async with session.get(f"{instance}/api/v1/videos/{video_id}") as resp:
                    if resp.status != 200:
                        continue
                    data = await resp.json()
                    title = data.get("title", "video")
                    
                    if is_audio:
                        streams = [s for s in data.get("adaptiveFormats", []) if s.get("type", "").startswith("audio")]
                        if streams:
                            streams.sort(key=lambda x: x.get("bitrate", 0), reverse=True)
                            return await download_from_url(uid, streams[0]["url"], msg, f"{safe_name(title)}.mp3", quality)
                    else:
                        target = int(quality) if quality.isdigit() else 720
                        for s in data.get("formatStreams", []):
                            res = s.get("resolution", "")
                            if "p" in res and int(res.replace("p", "")) <= target:
                                return await download_from_url(uid, s["url"], msg, f"{safe_name(title)}.mp4", quality)
        except:
            continue
    
    raise Exception("Invidious failed")

async def download_cobalt(uid: int, url: str, msg, quality: str = "720"):
    await safe_edit(msg, "ğŸ”„ **Trying Cobalt...**", cancel_kb())
    
    instances = ["https://co.wuk.sh"]
    timeout = ClientTimeout(total=60)
    is_audio = quality.startswith("mp3")
    
    for instance in instances:
        try:
            payload = {
                "url": url,
                "vCodec": "h264",
                "vQuality": quality if quality.isdigit() else "720",
                "aFormat": "mp3" if is_audio else "best",
                "isAudioOnly": is_audio,
            }
            async with ClientSession(timeout=timeout) as session:
                async with session.post(f"{instance}/api/json", json=payload) as resp:
                    if resp.status != 200:
                        continue
                    data = await resp.json()
                    if data.get("status") in ["redirect", "stream"] and data.get("url"):
                        ext = ".mp3" if is_audio else ".mp4"
                        return await download_from_url(uid, data["url"], msg, f"video_{int(time.time())}{ext}", quality)
        except:
            continue
    
    raise Exception("Cobalt failed")

async def download_video(uid: int, url: str, msg, quality: str = "720"):
    errors = []
    
    allowed, remaining = check_daily_limit(uid)
    if not allowed:
        raise Exception(f"Daily limit (5GB) exceeded!\nRemaining: {human_size(remaining)}")
    
    # Try Invidious first for YouTube
    if is_yt(url):
        try:
            return await download_invidious(uid, url, msg, quality)
        except Exception as e:
            if "CANCELLED" in str(e):
                raise
            errors.append(f"Invidious: {str(e)[:30]}")
    
    # Try Cobalt
    try:
        return await download_cobalt(uid, url, msg, quality)
    except Exception as e:
        if "CANCELLED" in str(e):
            raise
        errors.append(f"Cobalt: {str(e)[:30]}")
    
    # Try yt-dlp
    try:
        return await download_ytdlp(uid, url, msg, quality)
    except Exception as e:
        if "CANCELLED" in str(e):
            raise
        errors.append(f"yt-dlp: {str(e)[:30]}")
    
    raise Exception("All methods failed:\n" + "\n".join(errors))

async def download_direct(uid: int, url: str, msg):
    return await download_from_url(uid, url, msg, None, "720")

# =======================
# SCREENSHOTS
# =======================
async def make_ss(path: str, count: int = 5):
    screens = []
    out = os.path.join(DOWNLOAD_DIR, f"ss_{int(time.time())}")
    os.makedirs(out, exist_ok=True)
    try:
        cmd = f'ffprobe -v error -show_entries format=duration -of csv=p=0 "{path}"'
        proc = await asyncio.create_subprocess_shell(cmd, stdout=asyncio.subprocess.PIPE)
        stdout, _ = await proc.communicate()
        dur = float(stdout.decode().strip() or "0")
        if dur <= 0:
            return [], out
        interval = dur / (count + 1)
        for i in range(1, count + 1):
            o = os.path.join(out, f"{i}.jpg")
            c = f'ffmpeg -ss {interval * i} -i "{path}" -vframes 1 -q:v 5 -y "{o}" 2>/dev/null'
            p = await asyncio.create_subprocess_shell(c)
            await p.wait()
            if os.path.exists(o):
                screens.append(o)
        return screens, out
    except:
        return [], out

# =======================
# UPLOAD
# =======================
async def do_upload(uid, msg, path, name, as_video):
    user = user_get(uid)
    thumb = user.get("thumb") if user.get("thumb") and os.path.exists(user.get("thumb")) else None
    size = os.path.getsize(path)
    
    allowed, remaining = check_daily_limit(uid, size)
    if not allowed:
        raise Exception(f"Daily limit exceeded! Remaining: {human_size(remaining)}")
    
    start_time = time.time()
    last = {"t": 0}
    
    async def prog(done, total):
        sess = session_get(uid)
        if sess and sess.get("cancel"):
            raise Exception("CANCELLED")
        now = time.time()
        if now - last["t"] < 2:
            return
        last["t"] = now
        pct = (done / total * 100) if total > 0 else 0
        await safe_edit(msg, f"ğŸ“¤ **Uploading...**\n\n`[{progress_bar(pct)}]` {pct:.1f}%", cancel_kb())
    
    if as_video:
        await app.send_video(uid, path, caption=f"ğŸ¬ `{name}`", file_name=name, supports_streaming=True, thumb=thumb, progress=prog)
        await safe_edit(msg, "ğŸ“¸ **Screenshots...**", None)
        ss, ss_dir = await make_ss(path, 5)
        if ss:
            try:
                await app.send_media_group(uid, [types.InputMediaPhoto(s) for s in ss])
            except:
                pass
        shutil.rmtree(ss_dir, ignore_errors=True)
    else:
        await app.send_document(uid, path, caption=f"ğŸ“„ `{name}`", file_name=name, thumb=thumb, progress=prog)
    
    if uid != OWNER_ID and not user.get("is_pro"):
        user["used"] = user.get("used", 0) + size
        db_save()

# =======================
# BOT CLIENT
# =======================
app = Client("bot", api_id=API_ID, api_hash=API_HASH, bot_token=BOT_TOKEN, workdir="/tmp")

# =======================
# HANDLERS
# =======================
@app.on_message(filters.command("start") & filters.private)
async def cmd_start(_, m):
    uid = m.from_user.id
    user = user_get(uid)
    db_save()
    
    if user.get("is_banned"):
        return await m.reply_text("ğŸš« Banned.")
    
    if uid == OWNER_ID:
        expired, expiry, msg_text = check_cookies_expiry()
        return await m.reply_text(
            f"ğŸ‘‘ **Welcome Boss!**\n\n"
            f"ğŸª Cookies: {msg_text}\n"
            f"ğŸ”‘ YT API: {'âœ…' if YOUTUBE_API_KEY else 'âŒ'}\n\n"
            f"Send any link to download!",
            reply_markup=menu_kb(uid)
        )
    
    if not await is_subscribed(uid):
        return await m.reply_text(
            "âš ï¸ **Join our channel first!**\n\n"
            "1ï¸âƒ£ Click 'Join Channel'\n"
            "2ï¸âƒ£ Join the channel\n"
            "3ï¸âƒ£ Click 'Verify'",
            reply_markup=join_kb()
        )
    
    used = user.get("used", 0)
    remaining = DAILY_LIMIT - used
    await m.reply_text(
        f"ğŸ‘‹ Hi **{m.from_user.first_name}**!\n\n"
        f"ğŸ“Š Daily limit: {human_size(remaining)} left\n\n"
        f"Send any video link!",
        reply_markup=menu_kb(uid)
    )

@app.on_message(filters.text & filters.private & ~filters.command(["start"]))
async def on_text(_, m):
    uid = m.from_user.id
    user = user_get(uid)
    text = m.text.strip()
    
    if user.get("is_banned"):
        return
    
    if uid != OWNER_ID and not await is_subscribed(uid):
        return await m.reply_text("âš ï¸ Join channel first!", reply_markup=join_kb())
    
    # States
    if user.get("state") == "rename":
        sess = session_get(uid)
        if sess:
            new = safe_name(text) + sess.get("ext", "")
            sess["name"] = new
            session_set(uid, sess)
        user["state"] = "none"
        db_save()
        return await m.reply_text(f"âœ… `{new}`", reply_markup=upload_kb())
    
    if user.get("state") == "broadcast" and uid == OWNER_ID:
        user["state"] = "none"
        user["bc"] = text
        db_save()
        return await m.reply_text(f"ğŸ“¢ Preview:\n\n{text}", reply_markup=bc_kb())
    
    if user.get("state") == "addpro" and uid == OWNER_ID:
        user["state"] = "none"
        db_save()
        try:
            user_get(int(text))["is_pro"] = True
            db_save()
            return await m.reply_text("âœ… PRO added!", reply_markup=admin_kb())
        except:
            return await m.reply_text("âŒ Invalid!", reply_markup=admin_kb())
    
    if user.get("state") == "ban" and uid == OWNER_ID:
        user["state"] = "none"
        db_save()
        try:
            user_get(int(text))["is_banned"] = True
            db_save()
            return await m.reply_text("âœ… Banned!", reply_markup=admin_kb())
        except:
            return await m.reply_text("âŒ Invalid!", reply_markup=admin_kb())
    
    if user.get("state") == "unban" and uid == OWNER_ID:
        user["state"] = "none"
        db_save()
        try:
            user_get(int(text))["is_banned"] = False
            db_save()
            return await m.reply_text("âœ… Unbanned!", reply_markup=admin_kb())
        except:
            return await m.reply_text("âŒ Invalid!", reply_markup=admin_kb())
    
    if not text.startswith("http"):
        return
    
    allowed, remaining = check_daily_limit(uid)
    if not allowed:
        return await m.reply_text(f"âŒ Daily limit exceeded!\nRemaining: {human_size(remaining)}")
    
    status = await m.reply_text("ğŸ” **Analyzing...**", reply_markup=cancel_kb())
    session_set(uid, {"url": text, "cancel": False})
    
    if is_yt(text) or is_instagram(text):
        platform = "ğŸ¬ YouTube" if is_yt(text) else "ğŸ“¸ Instagram"
        return await safe_edit(status, f"{platform}\n\nChoose quality:", yt_kb())
    
    try:
        path, title = await download_direct(uid, text, status)
        name = os.path.basename(path)
        size = os.path.getsize(path)
        session_set(uid, {"url": text, "path": path, "name": name, "ext": get_ext(name), "size": size, "cancel": False})
        await safe_edit(status, f"âœ… Done!\n\nğŸ“„ `{name}`\nğŸ“¦ {human_size(size)}", upload_kb())
    except Exception as e:
        session_clear(uid)
        await safe_edit(status, f"âŒ {str(e)[:150]}" if "CANCELLED" not in str(e) else "âŒ Cancelled!", None)

@app.on_message((filters.video | filters.document | filters.audio) & filters.private)
async def on_file(_, m):
    uid = m.from_user.id
    user = user_get(uid)
    if user.get("is_banned"):
        return
    if uid != OWNER_ID and not await is_subscribed(uid):
        return await m.reply_text("âš ï¸ Join first!", reply_markup=join_kb())
    
    media = m.video or m.document or m.audio
    status = await m.reply_text("â¬‡ï¸ Downloading...", reply_markup=cancel_kb())
    session_set(uid, {"cancel": False})
    
    try:
        name = safe_name(getattr(media, "file_name", None) or f"file_{int(time.time())}")
        path = os.path.join(DOWNLOAD_DIR, name)
        await m.download(path)
        size = os.path.getsize(path)
        session_set(uid, {"path": path, "name": name, "ext": get_ext(name), "size": size, "cancel": False})
        await safe_edit(status, f"âœ… `{name}`\nğŸ“¦ {human_size(size)}", upload_kb())
    except Exception as e:
        session_clear(uid)
        await safe_edit(status, f"âŒ {str(e)[:80]}", None)

@app.on_message(filters.photo & filters.private)
async def on_photo(_, m):
    uid = m.from_user.id
    if user_get(uid).get("is_banned"):
        return
    if uid != OWNER_ID and not await is_subscribed(uid):
        return await m.reply_text("âš ï¸ Join first!", reply_markup=join_kb())
    path = os.path.join(THUMB_DIR, f"{uid}.jpg")
    await m.download(path)
    user_get(uid)["thumb"] = path
    db_save()
    await m.reply_text("âœ… Thumbnail saved!")

@app.on_callback_query()
async def on_cb(_, cb):
    uid = cb.from_user.id
    data = cb.data
    user = user_get(uid)
    sess = session_get(uid)
    
    await cb.answer()
    
    if user.get("is_banned"):
        return
    
    if data == "verify_join":
        if uid == OWNER_ID or await is_subscribed(uid):
            await cb.answer("âœ… Verified!", show_alert=True)
            return await safe_edit(cb.message, f"âœ… Welcome!", menu_kb(uid))
        await cb.answer("âŒ Join the channel first!", show_alert=True)
        return
    
    if data not in ["close"] and uid != OWNER_ID and not await is_subscribed(uid):
        await cb.answer("âš ï¸ Join first!", show_alert=True)
        return await safe_edit(cb.message, "âš ï¸ Join channel!", join_kb())
    
    if data == "close":
        try:
            await cb.message.delete()
        except:
            pass
        return
    
    if data == "cancel":
        if sess:
            sess["cancel"] = True
            session_set(uid, sess)
            if sess.get("path") and os.path.exists(sess["path"]):
                try:
                    os.remove(sess["path"])
                except:
                    pass
        session_clear(uid)
        user["state"] = "none"
        db_save()
        return await safe_edit(cb.message, "âŒ Cancelled!", None)
    
    if data == "back":
        user["state"] = "none"
        db_save()
        return await safe_edit(cb.message, "ğŸ“‹ Menu", menu_kb(uid))
    
    if data == "menu_thumb":
        return await safe_edit(cb.message, "ğŸ–¼ï¸ Send photo for thumbnail", thumb_kb())
    
    if data == "menu_stats":
        if uid == OWNER_ID:
            expired, expiry, msg = check_cookies_expiry()
            exp_str = expiry.strftime('%Y-%m-%d') if expiry else "Unknown"
            return await safe_edit(cb.message,
                f"ğŸ“Š **Stats**\n\nğŸ‘¥ Users: {len(DB['users'])}\nğŸª Cookies: {msg}\nğŸ“… Expiry: {exp_str}",
                menu_kb(uid))
        used = user.get("used", 0)
        return await safe_edit(cb.message, f"ğŸ“Š Used: {human_size(used)} / 5GB", menu_kb(uid))
    
    if data == "menu_help":
        return await safe_edit(cb.message, "â“ Send link â†’ Choose quality â†’ Upload\n\nğŸ“Š Limit: 5GB/day", menu_kb(uid))
    
    if data == "thumb_view":
        t = user.get("thumb")
        if t and os.path.exists(t):
            await cb.message.reply_photo(t)
        else:
            await cb.answer("No thumbnail!", show_alert=True)
        return
    
    if data == "thumb_del":
        t = user.get("thumb")
        if t and os.path.exists(t):
            os.remove(t)
        user["thumb"] = None
        db_save()
        return await safe_edit(cb.message, "âœ… Deleted!", thumb_kb())
    
    if data == "admin" and uid == OWNER_ID:
        return await safe_edit(cb.message, "âš™ï¸ Admin", admin_kb())
    
    if data == "adm_stats" and uid == OWNER_ID:
        expired, expiry, msg = check_cookies_expiry()
        return await safe_edit(cb.message,
            f"ğŸ“Š Users: {len(DB['users'])}\nğŸª {msg}\nğŸ“… {expiry.strftime('%Y-%m-%d') if expiry else 'N/A'}",
            admin_kb())
    
    if data == "adm_cookies" and uid == OWNER_ID:
        expired, expiry, msg = check_cookies_expiry()
        exp_str = expiry.strftime('%Y-%m-%d %H:%M') if expiry else "Unknown"
        return await safe_edit(cb.message,
            f"ğŸª **Cookies**\n\nStatus: {msg}\nExpiry: `{exp_str}`\n\nUpdate in Koyeb if expired.",
            admin_kb())
    
    if data == "adm_bc" and uid == OWNER_ID:
        user["state"] = "broadcast"
        db_save()
        return await safe_edit(cb.message, "ğŸ“¢ Send message:", cancel_kb())
    
    if data == "bc_yes" and uid == OWNER_ID:
        text = user.get("bc", "")
        if text:
            sent = 0
            for u in DB["users"]:
                try:
                    await app.send_message(int(u), text)
                    sent += 1
                    await asyncio.sleep(0.05)
                except:
                    pass
            user["bc"] = ""
            db_save()
            return await safe_edit(cb.message, f"âœ… Sent to {sent}!", admin_kb())
    
    if data == "bc_cancel":
        user["state"] = "none"
        user["bc"] = ""
        db_save()
        return await safe_edit(cb.message, "âŒ Cancelled", admin_kb())
    
    if data == "adm_pro" and uid == OWNER_ID:
        user["state"] = "addpro"
        db_save()
        return await safe_edit(cb.message, "ğŸ‘‘ Send user ID:", cancel_kb())
    
    if data == "adm_ban" and uid == OWNER_ID:
        user["state"] = "ban"
        db_save()
        return await safe_edit(cb.message, "ğŸš« Send user ID:", cancel_kb())
    
    if data == "adm_unban" and uid == OWNER_ID:
        user["state"] = "unban"
        db_save()
        return await safe_edit(cb.message, "âœ… Send user ID:", cancel_kb())
    
    if data.startswith("yt_"):
        if not sess or not sess.get("url"):
            return await safe_edit(cb.message, "âŒ Session expired!", None)
        
        quality = data.replace("yt_", "")
        try:
            path, title = await download_video(uid, sess["url"], cb.message, quality)
            name = os.path.basename(path)
            size = os.path.getsize(path)
            session_set(uid, {"url": sess["url"], "path": path, "name": name, "ext": get_ext(name), "size": size, "cancel": False})
            await safe_edit(cb.message, f"âœ… Done!\n\nğŸ“„ `{name}`\nğŸ“¦ {human_size(size)}", upload_kb())
        except Exception as e:
            session_clear(uid)
            await safe_edit(cb.message, f"âŒ {str(e)[:150]}" if "CANCELLED" not in str(e) else "âŒ Cancelled!", None)
        return
    
    if data == "rename" and sess:
        return await safe_edit(cb.message, f"âœï¸ Current: `{sess['name']}`", rename_kb())
    
    if data == "ren_def" and sess:
        return await safe_edit(cb.message, f"ğŸ“ `{sess['name']}`", upload_kb())
    
    if data == "ren_cust" and sess:
        user["state"] = "rename"
        db_save()
        return await safe_edit(cb.message, "âœï¸ Send new name:", cancel_kb())
    
    if data == "back_up" and sess:
        return await safe_edit(cb.message, f"ğŸ“„ `{sess['name']}`", upload_kb())
    
    if data in ["up_file", "up_video"]:
        if not sess or not sess.get("path") or not os.path.exists(sess["path"]):
            session_clear(uid)
            return await safe_edit(cb.message, "âŒ File not found!", None)
        try:
            await do_upload(uid, cb.message, sess["path"], sess["name"], data == "up_video")
            try:
                os.remove(sess["path"])
            except:
                pass
            session_clear(uid)
            await safe_edit(cb.message, "âœ… Done!", menu_kb(uid))
        except Exception as e:
            await safe_edit(cb.message, f"âŒ {str(e)[:100]}" if "CANCELLED" not in str(e) else "âŒ Cancelled!", None)

# =======================
# MAIN
# =======================
async def health(_):
    return web.Response(text="OK")

async def main():
    os.makedirs(DOWNLOAD_DIR, exist_ok=True)
    os.makedirs(THUMB_DIR, exist_ok=True)
    db_load()
    setup_cookies()
    
    await app.start()
    
    # Notify owner about cookie status on startup
    expired, expiry, msg = check_cookies_expiry()
    if expired:
        await notify_owner(f"ğŸš¨ **Cookie Alert**\n\n{msg}\n\nUpdate COOKIES in Koyeb!")
    
    print("=" * 50)
    print("âœ… BOT STARTED!")
    print(f"ğŸ‘‘ Owner: {OWNER_ID}")
    print(f"ğŸª Cookies: {msg}")
    print("=" * 50)
    
    srv = web.Application()
    srv.add_routes([web.get("/", health)])
    runner = web.AppRunner(srv)
    await runner.setup()
    await web.TCPSite(runner, "0.0.0.0", 8000).start()
    
    await idle()
    await app.stop()

if __name__ == "__main__":
    app.run(main())
